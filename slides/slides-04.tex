%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[12pt,dvipdfmx]{beamer}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% pdfの栞・プロパティの字化けを防ぐ
\usepackage{atbegshi}
%\AtBeginShipoutFirst{\special{pdf:tounicode 90ms-RKSJ-UCS2}} %Windows
\AtBeginShipoutFirst{\special{pdf:tounicode EUC-UCS2}} %Linux, Mac
\usepackage{hyperref}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% テーマの指定、省略時は default になる
%%%

 % フレームの指定、省略可
%%%%%%%%%%%%%%%%%%%%%%%%%%%% THEME
  %\usetheme{AnnArbor}
  %\usetheme{Antibes}
  %\usetheme{Bergen}
  %\usetheme{Berkeley}
  %\usetheme{Berlin}
  \usetheme{Boadilla}
  %\usetheme{boxes}
  %\usetheme{CambridgeUS}
  %\usetheme{Copenhagen}
  %\usetheme{Darmstadt}
  %\usetheme{default}
  %\usetheme{Dresden}
  %\usetheme{Frankfurt}
  %\usetheme{Goettingen}
  %\usetheme{Hannover}
  %\usetheme{Ilmenau}
  %\usetheme{JuanLesPins}
  %\usetheme{Luebeck}
  %\usetheme{Madrid}
  %\usetheme{Malmoe}
  %\usetheme{Marburg}
  %\usetheme{Montpellier}
  %\usetheme{PaloAlto}
  %\usetheme{Pittsburgh}
  %\usetheme{Rochester}
  %\usetheme{Singapore}
  %\usetheme{Szeged}
  %\usetheme{Warsaw}

% 省略可
%%%%%%%%%%%%%%%%%%%%%%%%%%%% COLOR THEME
  %\usecolortheme{albatross}
  %\usecolortheme{beetle}
  %\usecolortheme{crane}
  %\usecolortheme{default}
  %\usecolortheme{dolphin}
  %\usecolortheme{dove}
  %\usecolortheme{fly}
  %\usecolortheme{lily}
  %\usecolortheme{orchid}
  %\usecolortheme{rose}
  %\usecolortheme{seagull}
  %\usecolortheme{seahorse}
  %\usecolortheme{sidebartab}
  %\usecolortheme{structure}
  %\usecolortheme{whale}

% ヘッダ、フッタ、フレーム等を指定、省略可
  %%%%%%%%%%%%%%%%%%%%%%%%%%%% OUTER THEME
  %\useoutertheme{default}
  %\useoutertheme{infolines}
  %\useoutertheme{miniframes}
  %\useoutertheme{shadow}
  %\useoutertheme{sidebar}
  %\useoutertheme{smoothbars}
  %\useoutertheme{smoothtree}
  %\useoutertheme{split}
  %\useoutertheme{tree}

% タイトル、section, itemize/enumerate 環境、
% theorem 環境、図, 参考文献などのスタイルを指定、
% 省略可
  %%%%%%%%%%%%%%%%%%%%%%%%%%%% INNER THEME
  %\useinnertheme{circles}
  %\useinnertheme{default}
  %\useinnertheme{inmargin}
  \useinnertheme{rectangles}
  %\useinnertheme{rounded}


%\usefonttheme{}	% 省略可
%\logo{}		% 省略可

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% navi. symbolsは目立たないが，dvipdfmxを使うと機能しないので非表示に
\setbeamertemplate{navigation symbols}{}

% 各種パッケージ
\usepackage{graphicx}
%\usepackage{url,cite}
\usepackage{amsmath}
\usepackage{amsthm} \theoremstyle{definition} %theorem環境が斜体になるので注意
\usepackage{amssymb} % AMS-TeX
\usepackage{setspace}

% \AtBeginSection[] % Do nothing for \section*
% { \begin{frame}<beamer> \frametitle{}
%    \tableofcontents[currentsection,subsectionstyle=hide]
%  \end{frame} } 

%appendixをページカウントしない
\newcommand{\backupbegin}{
   \newcounter{framenumberappendix}
   \setcounter{framenumberappendix}{\value{framenumber}}
}
\newcommand{\backupend}{
   \addtocounter{framenumberappendix}{-\value{framenumber}}
   \addtocounter{framenumber}{\value{framenumberappendix}} 
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 本文・数式フォント
%\usepackage{palatino,mathpazo}
%\usepackage{times,mathptmx}
\usepackage[varg]{txfonts}
%\usepackage[varg]{pxfonts}

% \mathcal(\cal)の扱い
%\DeclareMathAlphabet{\mathcal}{OMS}{cmsy}{m}{n} %computer modern
%\DeclareMathAlphabet{\mathcal}{OMS}{txsy}{m}{n} %txfont
%\usepackage[psamsfonts]{eucal} % euler

% mathptmx時に数式モードのvをtxfontから借りる
% \DeclareSymbolFont{lettersA}{U}{txmia}{m}{it}
% \SetSymbolFont{lettersA}{bold}{U}{txmia}{bx}{it}
% \DeclareFontSubstitution{U}{txmia}{m}{it}
% \DeclareMathSymbol{v}{\mathalpha}{lettersA}{"33} %"

\usepackage{multirow}

%上線 widebar, Widebar
\usepackage{accents}
\makeatletter
\def\widebar{\accentset{{\cc@style\underline{\mskip11mu}}}}
\makeatother


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 定理環境
% \newtheorem{theorem}{Theorem}
% \newtheorem{lemma}[theorem]{Lemma}
% \newtheorem{corollary}[theorem]{Corollary}
% \newtheorem{definition}[theorem]{Definition}
% \newtheorem{example}[theorem]{Example}
\newtheorem{proposition}{Proposition}
\newtheorem{remark}{Remark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 各種コマンド定義等
\def\Fig#1{Fig.\@\ref{#1}}
\def\Table#1{Table~\ref{#1}}
\def\Eq#1{Eq.\@(\ref{#1})}
\def\Eqs#1{Eqs.\@(\ref{#1})}
\def\Thm#1{Theorem~\ref{#1}}
\def\Lma#1{Lemma~\ref{#1}}
\def\Sect#1{Section~\ref{#1}}
\def\Rmk#1{Remark~\ref{#1}}
\def\Prop#1{Proposition~\ref{#1}}
\def\Coro#1{Corollary~\ref{#1}}
\def\Def#1{Definition~\@\ref{#1}}
\def\Prob#1{Problem~\@\ref{#1}}
\def\ie{{i.\@e.\@,~}}
\def\eg{{e.\@g.\@,~}}
\def\etal{{et al.}}

% 数式環境用
\def\rank{\mathsf{rank}\, }
\def\dim{\mathsf{dim}\, }
\def\rspace{\mathsf{span}}
\def\supp{\mathsf{supp}}
%\def\vec#1{\mathbf{#1}}
\def\F{\mathbb{F}}
\def\wt{\mathsf{wt}}
\def\c{\mathcal{C}}
\def\dc{\mathcal{C}^{\perp}}
\def\d{\mathcal{D}}
\def\dd{\mathcal{D}^{\perp}}
\def\g{\mathcal{G}}
\def\dg{\mathcal{G}^{\perp}}
\def\p{\mathcal{P}}
% \def\rspace{\mathsf{span}}
\def\supp{\mathsf{supp}}
\def\ker{\mathsf{Ker\ }}

%\def\bari#1{\{\widebar{#1}\}}
\def\bari#1{\,\overline{{\!\{#1\}\!}}\,}
%\def\bari#1{\bar{\{#1\}}}
\def\vecxi{Z_{\bari{i}}}
%\def\vecsxi{\vec{z}_i}
\def\tvector{X}
\def\tpackets{X_1,\dots,X_n}
\def\mvector{S}
\def\mpackets{S_1,\dots,S_l}
\def\rvector{Y}
\def\wvector{W}
\def\cvector{C}
\def\cword{C_{1},\dots,C_{l+n}}
\def\pcword{C_{l+1},\dots,C_{l+n}}
\def\randvector{R}

\def\compmat{\Phi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%%  日本語フォントをゴシックに、数式フォントを太字に変更する
%%%
\renewcommand{\kanjifamilydefault}{\gtdefault}
\renewcommand{\familydefault}{\sfdefault}

\setbeamerfont{title}{size=\large,series=\bfseries}
\setbeamerfont{frametitle}{size=\large,series=\bfseries}
%\setbeamertemplate{frametitle}[default][center]
\usefonttheme{professionalfonts} 

%\mathversion{bold} %数式フォントを太字に

%\def\vec#1{\mbox{\boldmath $#1$}}


%\logo{\includegraphics[width=2cm]{titech_logo.eps}}

%\setbeamertemplate{caption}[numbered]
%%%
%%% 著者など
%%%
\title[E2E Security with JS 04]{JavaScriptによるEnd-to-Endセキュリティ}
\subtitle{第4回 データの真正性・本人確認のためのテクニック 編}
\author[Jun Kurihara]{栗原 淳}
\institute[]{}
\date[]{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{frame}
\titlepage
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{はじめに}
\begin{frame}
 \centering
 {\Large はじめに}
\end{frame}

\begin{frame}
\frametitle{はじめに}
第1,2,3回では
\begin{itemize}
 \item End-to-End (E2E) セキュリティの原則と必要性
 \item JavaScriptでAESを使った暗号化のお作法
 \item JavaScriptで公開鍵暗号(RSA/楕円曲線)を使った暗号化のお作法
\end{itemize}
を勉強した。

\vspace{2ex}

今回は、第3回の最後に懸案事項だった\\
\alert{「データのやり取りしてる相手って本当に正しい相手？」}\\
を保証する方法を学んでいく。
\end{frame}


\begin{frame}
\frametitle{第3回のおさらい: Ephemeral Scheme}
\begin{block}{\small 公開鍵暗号化のEphemeral Schemeでの運用}
公開鍵・秘密鍵ペアを都度生成、1回限りで使い捨てることで、\alert{Perfect Forward Secrecy}\footnote[frame]{\scriptsize 長期的に保存されているマスター秘密鍵の漏洩や、一部の暗号化データがクラックされたとしても、\alert{それ以外の過去に暗号化されたデータは復号されてしまうことはない}という概念。}を担保する運用方法。
\end{block}

Perfect Forward Secrecyを守り、End-to-End暗号化の強固な運用を。
\end{frame}

\begin{frame}
\small 
\begin{center}
\includegraphics[width=0.7\linewidth]{Figs/ephemeral-scheme-flow01.pdf}\\
Ephemeral Schemeのイメージ
\end{center}
\vspace{-1ex}

まずはじめに、\alert{「送られてきたEphemeralな公開鍵は、本当に自分がやりとりしたい相手の公開鍵か?」の確認}が必須。\footnote[frame]{\scriptsize 意図しない相手の公開鍵で暗号化して機密データを漏らさぬように、ということ。}
\end{frame}

\begin{frame}

というわけで、「E2Eで安全にデータをやり取りする」ための基礎部分の最後のピースを今日は学ぶ。

\begin{block}{\small この講義で最終的に学びたいこと}
\begin{itemize}
\item 本人確認やデータの改ざん防止を担保する方法
\begin{itemize}
 \item データ毎に固有の指紋を生成する「\alert{ハッシュ}」
 \item 「共通鍵」を使った改ざん防止方法「\alert{MAC}」\footnote[frame]{\scriptsize HMAC (RFC2104 \url{https://tools.ietf.org/html/rfc2104})}
 \item 「公開鍵」を使った本人確認・改ざん防止方法「\alert{電子署名}」\footnote[frame]{\scriptsize RSASSA PKCS\#1-v1.5/PSS (PKCS\#1 RFC8017 \url{https://tools.ietf.org/html/rfc8017}), ECDSA (FIPS PUB186-4 \url{https://csrc.nist.gov/publications/detail/fips/186/4/final})}
\end{itemize}
\item そしてその具体的なJavaScriptでの実装方法・お作法
\end{itemize}
\end{block}

細かい話もするが、数式は使わない。

「イメージ」と「コードの流れ＆その流れの必要性」をつかめるようにする。
\end{frame}

\begin{frame}
\frametitle{この講義の対象と事前準備}
対象:
\begin{itemize}
\item 暗号・セキュリティ技術に興味がある初学者
\item Webに暗号技術を導入したいWeb系のエンジニア
\end{itemize}

\vspace{2ex}

必須ではないが触って楽しむのには必要な事前準備:
\begin{itemize}
\item Bash, Gitが使えるようになっていること
\item Node.js, npm, yarnが使えるようになっていること
\item Google Chrome系ブラウザ and/or Firefoxが利用可能なこと
\end{itemize}
\end{frame}

\begin{frame}
今回の位置付け:
\begin{enumerate}
 \item \textcolor{gray}{導入\&JSの暗号化コードを触ってみる}
 \item \textcolor{gray}{AESを正しく・安全に暗号化するには？}
 \item \textcolor{gray}{公開鍵暗号はどうやって使う？その使い方のコツは？}
 \item \alert{ハッシュ・MAC・署名、それぞれの使い所と使い方は？} ← 今日はココ
\end{enumerate}

\end{frame}

\input{frame-kurihara.tex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{サンプルコードの準備}
\begin{frame}
\centering
{\Large サンプルコードの準備}
\end{frame}

\begin{frame}
\frametitle{準備}
\small
説明を聞きつつ手を動かすため、まず環境準備。
\alert{今回は、JavaScript (Node.js) を使って手元でデータのHash/MAC/署名をいじってみる。}
そしてその効果を実感する。

\begin{center}
\includegraphics[width=0.7\linewidth]{Figs/md-flow.pdf}
\end{center}

\end{frame}

\begin{frame}

※\alert{サンプルコードはブラウザでも動く}。src/commands-browser.htmlを開くとこれからNode.JSで試すデモが開発者コンソールで実行される。適宜試したり比較すると良い。

\vspace{2ex}

※前回のコードの公開鍵に署名をつけたりしてEphemeral Schemeを作ってみると良い。
\end{frame}

\begin{frame}
\frametitle{環境}
以下の環境が前提:
\begin{itemize}
 \item Node.js ($>$ v10)がインストール済。yarnが使えること。 \footnote[frame]{インストールコマンド: \texttt{npm i -g yarn}}
 \item ブラウザとして、Google Chrome (系ブラウザ)、もしくはFirefoxがインストール済み
 \item Visual Studio Code や WebStorm などの統合開発環境がセットアップ済みだとなお良い。
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{JavaScriptプロジェクトの準備}
\begin{enumerate}
\item プロジェクトのGitHubリポジトリ\footnote[frame]{\url{https://github.com/zettant/e2e-security-04}}をClone\\
\begin{exampleblock}{}
\footnotesize
\$ \texttt{git clone https://github.com/zettant/e2e-security-04}\\
\$ \texttt{cd e2e-security-04/sample}
\end{exampleblock}
\item 依存パッケージのインストール
\begin{exampleblock}{}
\$ \texttt{yarn install}
\end{exampleblock}
\item ライブラリのビルド
\begin{exampleblock}{}
\$ \texttt{yarn build}
\end{exampleblock}
\end{enumerate}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Hash}
\begin{frame}
\centering
{\Large データの指紋: Hash}
\end{frame}

\begin{frame}
\frametitle{HashおよびHash関数とは}
\begin{block}{\small HashおよびHash関数}
あるデータに対し、そのデータを「代表するビット列」を計算する不可逆の関数を「Hash関数」。導出したビット列を「Hash」\footnote[frame]{あるいはHash値、Message Digest}と呼ぶ。
\end{block}
\begin{center}
\includegraphics[width=0.8\linewidth]{Figs/hash-flow01.pdf}
\end{center}
\end{frame}

\begin{frame}
 1ビットでもデータが異なれば、全く違うHashが導出される。
\begin{center}
 \includegraphics[width=0.8\linewidth]{Figs/hash-flow02.pdf}
\end{center}
\end{frame}

\begin{frame}
\small
\frametitle{HashおよびHash関数の役割}
同じくデータ固有のビット列を導出するChecksumと似ているが、その用途はより強力で多岐にわたる。

\begin{itemize}
 \item \textbf{Checksum}
\begin{itemize}
 \item 通信路上などでの\structure{データの(偶発的な)エラー検知}
\end{itemize}
$\Rightarrow$ \structure{データから一意に導ける値}・高速な処理が可能なことが必須
 \item \textbf{Hash}
\begin{itemize}
 \item \alert{データのエラー・改ざん検知}
 \item \alert{Hashをデータ実態の代替として署名を生成}
 \item 多数のデータの索引作成\footnote[frame]{Hash Table} 
 \item データの重複検出
\end{itemize}
$\Rightarrow$ \alert{別のデータ同士で同じHashを得ることが困難}なことが必須
\end{itemize}

\textbf{Checksum $\subseteq$ Hash} と言える。
\end{frame}

\begin{frame}
\frametitle{Hash関数の種類}
 MD5, SHA-1, SHA-2 (SHA-256, 384, 512), SHA-3というHash関数がよく知られている。
 \begin{center}
  \includegraphics[width=\linewidth]{Figs/hash-history.pdf}
 \end{center}
 MD5、SHA-1は、「\alert{同じHash(指紋)を生成するデータが割と簡単に見つけられる}\footnote[frame]{「衝突」と呼ぶ。MD5の場合は、$2^{20}$程度の計算量でクラック可能。}」という致命的な欠陥が発見されている。
\end{frame}

\begin{frame}
\begin{block}{\small Hash関数の選択について}
\begin{itemize}
 \item 理由がなければSHA-2シリーズ以降のものを選択する。
\begin{itemize}
 \item bit長は長いほど、衝突するデータが見つけづらい(=強固)
 \item ただし、bit長が長いほど、計算が重くなる
\end{itemize}
 \item SHA-1/MD5は、基本的に互換性の担保のためだけに利用する。但し、Checksumとして使う分には概ね問題ない。\alert{何が何でも使うな、というわけではない。}
\end{itemize}
\end{block}

\begin{exampleblock}{\small IE/Edge こぼれ話}
\small
X.509の公開鍵証明書などはまだSHA-1が利用されている場合が多々ある。しかし、\alert{IE/Edgeでは互換性の担保を全て無視してSHA-1のネイティブサポートを全打ち切り}しているので、X.509公開鍵証明書などをJavaScriptからネイティブAPIを通して扱えない。
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
\frametitle{JavaScriptでデータのHashを生成してみる。}
\begin{exampleblock}{}
\scriptsize
\begin{verbatim}
% yarn execute gen-hash 'hello hash world!' // デフォルトのhash関数は'SHA-256'
<Computed Hash>
70c6b0c909b7a3b4932e6e6d27c6e3c8106b7b9487a4ab9fb27d698b0bee601d // 'SHA-256'で計算したhash
=======

% yarn execute gen-hash 'hello hash world!!' // 1文字増やす
<Computed Hash>
c1a548f16bc6cd013fb76f59c982c6dbc57d390d9a470e09b35d716c7716ab47 // 全く違うhash
=======

% yarn execute gen-hash 'hello hash world!' -h 'SHA3-256' // -hでhash関数指定
<Computed Hash>
cb352b3d82d5911b99774fcf534bfd024fc58ef58fb67db14f504931da9a333d
=======
\end{verbatim}
\end{exampleblock}

ちなみにbashだと、以下でSHA-256のhashをチェック可能。

\begin{exampleblock}{}
\scriptsize
\begin{verbatim}
% echo -n 'hello hash world!' | shasum -a 256   
70c6b0c909b7a3b4932e6e6d27c6e3c8106b7b9487a4ab9fb27d698b0bee601d  -
\end{verbatim}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]
Hash生成のコードはこんな感じ。

今回も手前味噌で恐縮だが\texttt{jscu}\footnote[frame]{https://github.com/junkurihara/jscu}を利用している。

\begin{block}{\small hash生成(src/test-apis.js)}
\scriptsize
\begin{verbatim}
// hashName = 'SHA-256', 'SHA-384', 'SHA-512', 'SHA-1', 'SHA3-256', etc...

const jscu = getJscu(); // jscuオブジェクト取得
const binary = jseu.encoder.stringToArrayBuffer(data); // stringをuint8arrayに

return jscu.hash.compute(binary, hashName); // hash値のpromiseを返す
\end{verbatim}
\end{block}
Node.js, ブラウザ共に全く同じコードで動作。SHA3もサポート。
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{本人確認の技術}
\begin{frame}
\centering
{\Large 本人確認の技術}
\end{frame}

\begin{frame}
\frametitle{「正しい相手から正しく送信されてきたデータか」？}
いわゆる「データの真正性と送信元の確認方法」には、大まかに2つの方法がある。
\begin{itemize}
 \item Message Authentication Code (MAC)
 \item 署名 (電子署名)
\end{itemize}

\end{frame}

\begin{frame}
両者とも、送信するデータからMAC/署名という検証用データを生成、元データに付与する形で送信。
\begin{center}
 \includegraphics[width=0.75\linewidth]{Figs/mac-sig-flow01.pdf}
\end{center}
受信したデータと、MAC/署名とを突合して、「送信元は意図している相手か？」「データは改ざんされてないか？」を検証。
\begin{center}
 \includegraphics[width=0.75\linewidth]{Figs/mac-sig-flow02.pdf}
\end{center}
\end{frame}

\begin{frame}
MAC・署名の中身に突っ込む前に、それぞれのざっくりとした定義とpros/consを説明する。
\end{frame}

\begin{frame}
\frametitle{Message Authentication Code (MAC)}
\begin{block}{\small MACによるデータ真正性と送信者の確認}
\begin{itemize}
\item 送信側・受信側で共有する鍵を使って\alert{データ・鍵固有のバイナリ(MAC)}を生成する方法。
\item 受信側で、\alert{送信側と同一のMACが作れるかどうか}をチェック。
\end{itemize}
\end{block}
\begin{center}
 \includegraphics[width=0.7\linewidth]{Figs/mac-flow01.pdf}
\end{center}
\end{frame}
\begin{frame}
MACの特徴:
\begin{itemize}
 \item 同じ鍵でも、データが異なれば出力されるMACも異なる。
 \item 同じデータでも、鍵が異なれば出力されるMACも異なる。
\end{itemize}
\begin{center}
 $\Downarrow$
\end{center}
すなわち、受信側で同一のMACが作れることを確認できれば、\\
\begin{itemize}
 \item \alert{鍵を共有する相手}から
 \item \alert{途中の改ざんなしで送られたデータ}であること
\end{itemize}
が保証される。
\end{frame}

\begin{frame}
\frametitle{署名 (電子署名)}
公開鍵・秘密鍵ペアをベースとした技術\footnote[frame]{\scriptsize ここでいう公開鍵・秘密鍵ペアは、公開鍵暗号化に使うものと全く一緒の概念。}：
\begin{block}{署名によるデータ真正性と送信者の確認}
\begin{itemize}
 \item 送信側は公開鍵・秘密鍵ペアを保有。
 \item 送信側は、データと自分の秘密鍵から署名を生成。
 \item 受信側は、受信データ、署名と公開鍵の間の一貫性をチェック。
\end{itemize}
\end{block}
\begin{center}
 \includegraphics[width=0.63\linewidth]{Figs/sig-flow01.pdf}
\end{center}
\end{frame}

\begin{frame}
署名の特徴:
\begin{itemize}
 \item データが改ざんされていたら、検証が失敗(falseが出力)。
 \item 意図する相手の秘密鍵\footnote[frame]{\scriptsize 自分が入手している公開鍵の対となる秘密鍵}で署名が作られていなければ、検証が失敗。
 \item \alert{MACと違って、秘密の情報(=鍵)を事前共有しなくて良い}
\end{itemize}

\begin{center}
 $\Downarrow$
\end{center}
すなわち、署名技術は、\\
\begin{itemize}
 \item 意図する送信者から
 \item 途中の改ざんなしで送られたデータなことを
 \item \alert{事前の秘密情報の共有なし}で
\end{itemize}
保証する。\footnote[frame]{\scriptsize 検証用の公開鍵は、信頼できる手段で入手済み、あるいはプリインストールされていると仮定}
\end{frame}

\begin{frame}
\frametitle{MACと署名のpros/cons}
じゃあ署名だけでMACは不要では？…そういうわけにはいかない。
\begin{table}
\centering
\begin{tabular}{|p{0.07\linewidth}||p{0.39\linewidth}|p{0.43\linewidth}|}
\hline
 & \textbf{Pros} & \textbf{Cons}\\
\hline
\hline
\textbf{MAC}
& ・一般的に\alert{高速}\footnote[frame]{\scriptsize AES (CMAC) とかHash (HMAC) とかを構成要素としているため。} & ・鍵の\structure{事前共有が必要} \\
& ・生成するMACサイズは{小さい}\footnote[frame]{\scriptsize 通常128--512bits程度。} & \\
\hline
\textbf{署名}
& ・鍵の\alert{事前共有が不要} & ・一般的に\structure{非常に遅い・重い}\\
& & ・生成する署名サイズは一般的に\structure{大きい}\footnote[frame]{\scriptsize ECDSAは小さく、256--512bits程度。RSA系は非常に大きく通常2048bits以上。} \\
\hline
\end{tabular}
\end{table}

$\Rightarrow$ AES/公開鍵暗号の関係と全く一緒で、使い所を考えて組み合わせて使う、もしくは場合に応じて使い分ける。

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MAC}
\begin{frame}
\centering

{\Large 共通鍵を使った改ざん検知・本人確認: MAC}

\end{frame}

\begin{frame}
\frametitle{Message Authentication Code (MAC) 事始め}
\begin{block}{\small MACを使った改ざん検知\&本人確認手続き}
\small
送信側、受信側で秘密の鍵(バイナリ列)を共有。
\begin{enumerate}
\item 送信側はデータと一緒に、データと鍵から生成したMACを送信。
\item 受信側は、鍵と受信したデータから、受け取ったMACと同じものが作れるかどうかをチェック。
\end{enumerate}
\end{block}

\begin{center}
\includegraphics[width=0.9\linewidth]{Figs/mac-flow02.pdf}
\end{center}
\end{frame}

\begin{frame}
MACを作る標準手法のバリエーション。 
\begin{itemize} 
 \item \alert{HMAC; Hash-based Message Authentication Code}
 \item CMAC; Cipher-based Message Authentication Code
 \item GMAC; Galois Message Authentication Code
 \item etc.
\end{itemize}
今回は、JSで一番使いやすいと思われるHMACを取り上げる。
\end{frame}


\begin{frame}
\frametitle{HMAC; Hash-based MAC}
\begin{block}{\small HMAC (RFC2104)\footnote[frame]{\scriptsize \url{https://tools.ietf.org/html/rfc2104}}}
\begin{itemize}
 \item 鍵付きHash\footnote[frame]{\scriptsize Keyed Hash}と呼ばれる、Hash関数ベースのMAC生成方法。
 \item HDKF (RFC5869)などの標準技術や、AWS Signature v4\footnote[frame]{\scriptsize AWS S3にクライアントからREST API経由でアップロードする時に一時的に生成するMAC}等、各所で利用されている。
\end{itemize}
\end{block}
\end{frame}

\begin{frame}
\underline{「鍵」と「データ」をまとめてHash関数に入れる}、と考えると、
\begin{itemize}
 \item 鍵・データ両者が正しくないと、正しいHashも生成不能(=MAC検証失敗)。
 \item MACから鍵・データの情報を逆算することはできない。
\end{itemize}
という特徴をイメージしやすい。
\end{frame}

\begin{frame}[fragile]
\frametitle{JavaScriptでHMACを実行してみる}
\begin{exampleblock}{}
\scriptsize
\begin{verbatim}
// HMAC用のHex鍵を生成。鍵長は使うhashのサイズと等しい。
% yarn execute gen-hex-key 32 

<Generated Hex Key>
6c9a34e979fc7701330ec75a1bc6acb589ebaf831c7941e042c9ded0b2741d8f
=======

// HMACを生成。デフォルトはSHA-256で実行。-hで変更可。
% yarn execute gen-hmac 'hello hmac world!'\
-k '6c9a34e979fc7701330ec75a1bc6acb589ebaf831c7941e042c9ded0b2741d8f' // Hex鍵

<Computed HMAC with SHA-256>
862e28454f635541ce194d3e4919327c9823830cb7174286aaced5fc61e96a46
=======

// HMACを検証
% yarn execute verify-hmac 'hello hmac world!'\
-k '6c9a34e979fc7701330ec75a1bc6acb589ebaf831c7941e042c9ded0b2741d8f'\ // Hex鍵
-m '862e28454f635541ce194d3e4919327c9823830cb7174286aaced5fc61e96a46' // Hex HMAC

<Verification result of given HMAC>
true
=======
\end{verbatim}
\end{exampleblock}
\end{frame}


\begin{frame}[fragile]
\begin{exampleblock}{}
\scriptsize
\begin{verbatim}
// データが書き換わると検証が失敗
% yarn execute verify-hmac 'hello hmac world!?'\ // ?を追加
-k '6c9a34e979fc7701330ec75a1bc6acb589ebaf831c7941e042c9ded0b2741d8f'\
-m '862e28454f635541ce194d3e4919327c9823830cb7174286aaced5fc61e96a46'

<Verification result of given HMAC>
false
=======

// HMACが書き換わっても検証が失敗。
% yarn execute verify-hmac 'hello hmac world!'\
-k '6c9a34e979fc7701330ec75a1bc6acb589ebaf831c7941e042c9ded0b2741d8f'\
-m '862e28454f635541ce194d3e4919327c9823830cb7174286aaced5fc61e96a47' //最後を書換

<Verification result of given HMAC>
false
=======
\end{verbatim}
\end{exampleblock}
もちろん鍵が書き換わっても検証が失敗する。
\end{frame}

\begin{frame}[fragile]
コードの中身はこんな感じ。
\begin{block}{\small HMAC生成 (src/test-apis.js)}
\scriptsize
\begin{verbatim}
const jscu = getJscu();

// hex stringやstringをuint8arrayに。
const binaryData = jseu.encoder.stringToArrayBuffer(data);
const binaryKey = jseu.encoder.hexStringToArrayBuffer(key);

// Promsieを返す。hash = 'SHA-256', etc...
return jscu.hmac.compute(binaryKey, binaryData, hash);
\end{verbatim}
\end{block}

\begin{block}{\small HMAC検証 (src/test-apis.js)}
\scriptsize
\begin{verbatim}
const jscu = getJscu();

// hex stringやstringをuint8arrayに。
const binaryData = jseu.encoder.stringToArrayBuffer(data);
const binaryKey = jseu.encoder.hexStringToArrayBuffer(key);
const binaryMac = jseu.encoder.hexStringToArrayBuffer(mac);

// Promiseを返す。hash = 'SHA-256', etc...
return jscu.hmac.verify(binaryKey, binaryData, binaryMac, hash);
\end{verbatim}
\end{block}

検証は、「受信側でもMACを生成→チェック」でもOK。
\end{frame}

\begin{frame}
\frametitle{その他のMAC (JSじゃビミョー…)}
\begin{block}{\small CMAC; Cipher-based MAC (NIST SP800-38B\footnote[frame]{\scriptsize https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38b.pdf})}
\alert{共通鍵暗号(e.g., AES)のCBCモードをHash関数がわりに使用}してMACを計算する。
「前のブロックの暗号文を使って次のブロックを暗号化する」という特徴を応用。
\end{block}

\begin{block}{\small GMAC; Galois MAC (NIST SP800-38D\footnote[frame]{\scriptsize https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf})}
共通鍵暗号(e.g., AES)の Galois Counter Mode (GCM) で暗号化と同時に生成されるMAC。
\alert{高速に計算できる代数演算\footnote[frame]{\scriptsize $\mathbb{F}[x]/(x^{128}\!+\!x^7\!+\!x^2\!+\!x\!+\!1) = \mathbb{F}_{2^{128}}$上の乗算}をHash関数がわりに使用}してMACを計算する。
GMAC単独で利用可。
\end{block}

※CMAC/GMAC共々暗号化と同時に計算されることが多く、単独で利用するケースはあまり見かけない。
\end{frame}

\begin{frame}

と、「標準技術」で「広く利用されている」MACアルゴリズムはあるが、\structure{JSのネイティブAPI\footnote[frame]{\scriptsize WebCrypto API, Node.js Crypto}でサポートされているMACは、現状HMACのみ…}

\vspace{2ex}

CMAC, GMACが使いたかったら自力実装 or npmjs.comで見つけて利用する。
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{署名}
\begin{frame}
\centering
{\Large 公開鍵を使った改ざん検知・本人確認: 署名}

\end{frame}

\begin{frame}
\frametitle{署名 事始め}

\begin{block}{\small 署名 (電子署名) を使った改ざん検知\&本人確認手続き}
受信側は、送信側の公開鍵を予めプリインストール。
\begin{itemize}
 \item 送信側の処理:
\begin{enumerate}
 \item データ$D$をHash関数で短縮\footnote[frame]{\scriptsize データ$D$そのものに直接署名を施すのは計算量的・データ量的に大変(e.g, 元データと同じかそれ以上の大きさの署名を作る羽目になる)なので、\alert{データの指紋(i.e., hash)に対して署名を施す}。}、hash
$h = \mathit{Hash}(D)$を導出。
 \item hash $h$に対して秘密鍵$\mathit{SK}$で署名$s = \mathit{Sign}(h, \mathit{SK})$を生成。

データ$D$と署名$s$とを一緒に受信側へ送付。
\end{enumerate}
 \item 受信側の処理:
\begin{enumerate}
 \item データ$D$のhash $h = \mathit{Hash}(D)$を導出。
 \item hash $h$と署名 $s$の一貫性を、公開鍵$\mathit{PK}$で検証。$\mathit{Verify}(h, s, \mathit{PK}) \in \{\mathsf{True}, \mathsf{False}\}$
\end{enumerate}
\end{itemize}
\end{block}
\end{frame}

\begin{frame}
ざっくりフロー図。
\begin{center}
\includegraphics[width=\linewidth]{Figs/sig-flow02.pdf}
\end{center}
このフローは、以下のように考えるとイメージがつきやすい\footnote[frame]{\scriptsize 但し、常に正しい表現ではないので注意。}
\begin{enumerate}
 \item 送信側は、hash $h$を\alert{秘密鍵で暗号化}して$s$を生成。
 \item 受信側は、$s$を\structure{公開鍵で復号}して$h'$を入手。

命題「$h' = \mathit{Hash}(D')$」が成立するか検証。
\end{enumerate}
\end{frame}

\begin{frame}
署名生成方式の標準方式のバリエーション。
\begin{itemize}
\item RSA暗号をベースとした手法:
\begin{itemize}
 \item RSASSA PSS
 \item RSASSA PKCS\#1-v1.5
\end{itemize}
\item 楕円曲線暗号をベースとした手法:
\begin{itemize}
 \item ECDSA
\end{itemize}
\item etc.\footnote[frame]{\scriptsize Digital Signature Algorithm; DSA (FIPS PUB 186-4 \url{https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf})など}
\end{itemize}
JSで使いやすいRSASSA PSS \& PKSC\#1-v1.5とECDSAについて取り上げる。
\end{frame}

\begin{frame}
細かく説明する前に…


\vspace{2ex}

署名において一番やばいのは、「誰かが自分を騙って署名を作ることができる」などという状況。
そのため、署名においても「公開鍵サイズの正しい選択」が重要。
\begin{block}{\small 前回の復習}
暗号化においてAES-128bitsと同程度の強度の公開鍵サイズは、
\begin{itemize}
\item RSA: $\geq$ 3072bits
\item ECC: $\geq$ 256bits
\end{itemize}
程度。
\end{block}
\alert{署名についても暗号化に求めるものと同程度、あるいはそれ以上の鍵サイズを担保}して、公開鍵から秘密鍵を作られる(i.e., 自分を騙られる)ことを防ぐ。
\end{frame}


\begin{frame}
\frametitle{RSASSA; RSA Signature Scheme with Appendix}
\begin{block}{\small RSASSA PKCS\#1-v1.5と、RSASSA PSSの違い}
暗号化と同様に、$h=\mathit{Hash}(D)$に対して署名を作る際、\underline{鍵長に合わせたパディングが必要}。そのパディングの方法が違う。
\end{block}

\begin{center}
\includegraphics[width=0.8\linewidth]{Figs/sig-rsa-padding.pdf}
\end{center}

\end{frame}

\begin{frame}
 \begin{block}{\small RSASSA PKCS\#1-v1.5 (RFC8017\footnote[frame]{\scriptsize https://tools.ietf.org/html/rfc8017})}
\begin{itemize}
 \item \structure{RSAES PKCS\#1-v1.5の署名版。} PCKS\#1のv1.5で標準化。SSL/TLSを含め、現在でも広く使われている。
 \item hash $h = \mathit{Hash}(D)$をDERエンコードしたデータ$T$に、公開鍵長まで以下のようなパディングを付与。
\begin{align*}
m = \mathtt{0x00 || 0x01 || RandomSequence || 0x00 ||} T
\end{align*}
 \item RSASSA PKCS\#1-v1.5は、\structure{hashではなく生の短いデータに対して署名を生成すると、署名からその元データを戻せちゃうという脆弱性}\footnote[frame]{\scriptsize Y. Desmedt et al., ``A Chosen Text Attack on the  RSA Cryptosystem and Some Discrete Logarithm Schemes,'' in \textit{Proc. CRYPTO 1985}, pp.516--522, 1985.、他。J. Coron (CRYPTO 1999)等。}が知られている。本人確認の意味なし。
 \item PCKS\#1 v2.2 (RFC8017)では、「仕様通りにhash使っていればとりあえず問題ないが、今後何があるか分からないので\alert{RSASSA-PSSを使うほうが無難}」と記載。
\end{itemize}
\end{block}
\end{frame}

\begin{frame}
\begin{block}{\small RSASSA-PSS (Probabilistic Signature Scheme, RFC8017\footnote[frame]{\scriptsize \url{https://tools.ietf.org/html/rfc8017}})}
\begin{itemize}
 \item \structure{RSAES OAEPの署名版。} RFC3447/PKCS\#1 v2.1 (2003年) で標準化策定。
 \item 署名対象データ$D$に対して、乱数成分(RandomSalt)を加えつつHash関数を2重掛けし、Padded data $m$を作っている。
\begin{align*}
h &= Hash(Hash(D), \texttt{RandomSalt}),\\
m &= \texttt{MaskedDataBlock} || h || \texttt{0xBC},
\end{align*}
MaskedDataBlockはヘッダ。
 \item RSASSA PKCS\#1-v1.5からの乗り換えが進みつつあるものの\alert{OAEP同様に未対応の暗号ライブラリも多い}。ただし、RFC標準的には、可能ならPSSを利用することを推奨。
\end{itemize}
\end{block}

\end{frame}

\begin{frame}
\frametitle{PSSのイメージ図}
\begin{center}
\includegraphics[width=0.8\linewidth]{Figs/pss.pdf}
\end{center}
元データ$D$に加え、padded data $m$があればSaltなどを逆計算可能。
\end{frame}


\begin{frame}[fragile]
\frametitle{JavaScriptでRSASSA-PSSを実行してみる}
では、RFC推奨となっているPSSを試す。(コピペ頑張って)
\begin{exampleblock}{}
\scriptsize
\begin{verbatim}
% yarn execute gen-rsa-key // RSA鍵ペアの生成。-bでビット数指定。
<Generated RSA Public Key>
30820122300d06092a864886f70d01010105000... // 公開鍵
<Generated RSA Private Key>
308204be020100300d06092a864886f70d01010... // 秘密鍵
=======

% yarn execute sign-rsa-pss 'hello rsa-pss world!'\ // RSASSA-PSS署名生成
  -s '308204be020100300d06092a864886f70d0...' // 秘密鍵
<Generated RSASSA-PSS Signature>
6e7c4632f62e354f0ac40f65c92cd3e5bec5f6f... // 生成された署名
=======

% yarn execute verify-rsa-pss 'hello rsa-pss world!'\ // RSASSA-PSS署名検証
  -p '30820122300d06092a864886f70d0101010...'\ // 公開鍵
  -t '6e7c4632f62e354f0ac40f65c92cd3e5bec...' // 受け取った署名
<Verification Result of RSASSA-PSS Signature>
true // 署名検証結果
=======
\end{verbatim}
\end{exampleblock}
使うhash関数は-hオプションで切り替えられる。

\end{frame}

\begin{frame}[fragile]
コードの中身はこんな感じ。

鍵生成は前回と一緒なので省略。


\begin{block}{\small 署名生成(src/test-apis.js)}
\scriptsize
\begin{verbatim}
const jscu = getJscu();

// uint8arrayへ変換
const binaryData = jseu.encoder.stringToArrayBuffer(data);
const privateKeyDer = jseu.encoder.hexStringToArrayBuffer(privateKeyHex);

const privateKey = new jscu.Key('der', privateKeyDer); // DERを読込

// hash = 'SHA-256', saltLength = 32
return jscu.pkc.sign(
  binaryData,
  privateKey,
  hash, // データを縮めるためのhash関数名
  {name: 'RSA-PSS', saltLength}
);
\end{verbatim}
\end{block}
\end{frame}

\begin{frame}[fragile]

\begin{block}{\small 署名検証(src/test-apis.js)}
\scriptsize
\begin{verbatim}
const jscu = getJscu();

// uint8arrayへ変換
const binaryData = jseu.encoder.stringToArrayBuffer(data);
const publicKeyDer = jseu.encoder.hexStringToArrayBuffer(publicKeyHex);
const signature = jseu.encoder.hexStringToArrayBuffer(signatureHex);

const publicKey = new jscu.Key('der', publicKeyDer);　// DER鍵を読込

// hash = 'SHA-256', saltLength = 32
jscu.pkc.verify(
  binaryData,
  signature,
  publicKey,
  hash, // データを縮めるためのhash関数名
  {name: 'RSA-PSS', saltLength}
); 
\end{verbatim}
\end{block}

\end{frame}

\begin{frame}
RSASSA-PSSは、Node.js Crypto/WebCrypto共にネイティブサポートされている。（WebCryptoはブラウザ次第）

しかし他の環境だと、\structure{OAEP同様、PSSに未対応なライブラリも多く注意が必要}。(最近までOpenSSLも未対応だった)
\end{frame}

\begin{frame}
\frametitle{ECDSA; Elliptic Curve Digital Signature Algorithm}
\begin{block}{\small ECDSA (NIST FIPS 186-4\footnote[frame]{\scriptsize \url{https://csrc.nist.gov/publications/detail/fips/186/4/final}})}
\begin{itemize}
 \item ECDHの署名版\footnote[frame]{\scriptsize 正しい表現ではないが、イメージでそう捉えて欲しい。}。NIST FIPS 186-3 (2009年) で標準化。\structure{Bitcoin blockchainにも使われていて、また注目度が上がった}。
 \item RSASSAとは異なり、事前のpaddingに気を使う必要がない。アルゴリズム内部でhash $h$を生成・利用している。すなわち、
\begin{align*}
 \mathtt{Signature} &= \mathit{SignECDSA}(D, \mathit{SK}),\\
 \{\mathtt{True}, \mathtt{False}\} & \ni \mathit{VerifyECDSA}(\mathtt{Signature}, D, \mathit{PK}),
\end{align*}
という直接のAPIがアルゴリズムレベルで提供される。\footnote[frame]{\scriptsize RSASSAも、普通のライブラリでは直接Sign/Verify可能なAPIが提供されるが、その実態はRSAのナイーブな署名生成・検証アルゴリズムのラッパー。}
 \item OpenSSLをはじめ\alert{ほとんどの現代的な暗号ライブラリが実装をサポート}している。
\end{itemize}
\end{block}
\end{frame}

\begin{frame}
RSASSAとECDSAの比較。(一般論。実装にもよる。)

\begin{table}
\centering
\begin{tabular}{|p{0.13\linewidth}||p{0.35\linewidth}|p{0.35\linewidth}|}
\hline
 & \textbf{Pros} & \textbf{Cons}\\
\hline
\hline
\textbf{RSASSA}
& ・\alert{署名検証が高速}。ECDSAと比較してもかなり速い。
& ・\structure{署名サイズが大きい}。公開鍵長に等しい(e.g., 3072bits)。\\
& & ・\structure{署名生成がかなり低速}。\\
\hline
\textbf{ECDSA}
& ・\alert{署名サイズが小さい}。 公開鍵長の倍(e.g., 512bits (256bits key))。
& ・署名生成・検証共に同じくらい低速。\\
\hline
\end{tabular}
\end{table}
どっち使えばいいかは利用環境に応じて選択したほうがいい。常にECDSAを使えばいいとかそういうわけではない。

\end{frame}

\begin{frame}[fragile]
\frametitle{JavaScriptでECDSAを実行してみる}
\begin{exampleblock}{}
\scriptsize
\begin{verbatim}
% yarn execute gen-ecc-key // ECC鍵ペアの生成。-cで楕円曲線パラメタ設定。
<Generated ECC Public Key>
3059301306072a8648ce3d020106082a8648ce3d03010703... // 公開鍵

<Generated ECC Private Key>
308193020100301306072a8648ce3d020106082a8648ce3d... // 秘密鍵
=======

% yarn execute sign-ecdsa 'hello ecdsa world!'\ // ECDSA署名生成
  -s '308193020100301306072a8648ce3d020106082a8648c...' // 秘密鍵

<Generated ECDSA Signature>
58e5d15be4e71f7e6fbd4662cdb31eca463ed855114ef8357bed9.... // 生成された署名
=======

% yarn execute verify-ecdsa 'hello ecdsa world!'\
  -p '3059301306072a8648ce3d020106082a8648ce3d03010...'\ // 公開鍵
  -t '58e5d15be4e71f7e6fbd4662cdb31eca463ed855114ef...' // 受け取った署名
<Verification Result of ECDSA Signature>
true // 署名検証結果
=======
\end{verbatim}
\end{exampleblock}
使うhash関数は-hオプションで切り替えられる。
\end{frame}

\begin{frame}[fragile]
コードの中身はこんな感じ。

鍵生成は前回と一緒なので省略。

\begin{block}{\small 署名生成(src/test-apis.js)}
\scriptsize
\begin{verbatim}
const jscu = getJscu();

// uint8arrayへ変換
const binaryData = jseu.encoder.stringToArrayBuffer(data);
const privateKeyDer = jseu.encoder.hexStringToArrayBuffer(privateKeyHex);

const privateKey = new jscu.Key('der', privateKeyDer); // DERを読込

// hash = 'SHA-256'
return jscu.pkc.sign(
  binaryData,
  privateKey,
  hash, // データを縮めるためのhash関数名
);
\end{verbatim}
\end{block}
\end{frame}

\begin{frame}[fragile]

\begin{block}{\small 署名検証(src/test-apis.js)}
\scriptsize
\begin{verbatim}
const jscu = getJscu();

// uint8arrayへ変換
const binaryData = jseu.encoder.stringToArrayBuffer(data);
const publicKeyDer = jseu.encoder.hexStringToArrayBuffer(publicKeyHex);
const signature = jseu.encoder.hexStringToArrayBuffer(signatureHex);

const publicKey = new jscu.Key('der', publicKeyDer);　// DER鍵を読込

// hash = 'SHA-256'
jscu.pkc.verify(
  binaryData,
  signature,
  publicKey,
  hash // データを縮めるためのhash関数名
); 
\end{verbatim}
\end{block}
RSASSA-PSSと異なり、Saltが不要になり、\alert{APIがよりシンプル！}
\end{frame}

\begin{frame}
ECDSAは、Node.js Crypto/WebCrypto共に（大体）ネイティブサポートされている。

\alert{ただし、パラメータによっては実装されていない可能性がある}ので注意。ブラウザ差異だけではなく、仕様にない可能性も。\footnote[frame]{\scriptsize JavaScriptでは曲線'P-256K'がネイティブではサポートされていないので、Bitcoin blockchainのECDSAは動作しない。jscuではpure jsで補っている。}
\end{frame}

\begin{frame}
\centering
{\Large MAC/署名の運用について}
\end{frame}

\begin{frame}
\frametitle{署名検証のブートストラップの問題}

Q: \alert{署名の検証用の公開鍵が正しいことはどうやって保証するの？}

\vspace{2ex}

$\Rightarrow$ 現状ではこの問題に対して\structure{仮定なしでOKな万能の解は未知}。どこかに仮定、\underline{信頼するという起点}を置いた暫定解がある感じ。


\end{frame}

\begin{frame}
\begin{block}{暫定解1: Trust Anchor}
Endごとに、\alert{検証用の公開鍵をアプリケーション・端末に固定で事前に埋め込んでおく}。そこだけは起点として無条件に信頼して使う。
\end{block}

※ SSHとかGitHubで行う「ホスト・サービスへの公開鍵の登録」、というのはこのTrust Anchorの登録になる。
\end{frame}

\begin{frame}
 
\begin{block}{暫定解2: PKIに頼る}
さらに\alert{Verisignとかに検証用の公開鍵に署名してもらって、公開鍵証明書を作る}。
公開鍵証明書自身はオンラインで取得するが、その\structure{Verisignの署名の検証はTrust Anchor…}(Verisignを信頼の起点にする)。
\end{block}

解2は、Verisignの鍵1つをTrust Anchorにすればいいので鍵を埋め込むような手間がかからないが、\structure{お金がかかる}\footnote[frame]{\scriptsize 賛否あるだろうが、Let's encrypt (\url{https://letsencrypt.org/}) を使えば無償でいける。\structure{ただしLet's encryptは厳密な本人確認とかせずに署名つけてくれるので…}}。


\end{frame}

\begin{frame}
\frametitle{署名・MACの使い分け}
処理の重さで使い分けるのが鉄則。

\begin{itemize}
 \item 暗号化されたデータのやり取りの手続きで、\alert{署名はエンド間でのイニシエーション}に使う
 \item \structure{MACはエンド間でなんども繰り返すような本人確認・データ整合性確認}に使う
\end{itemize}

\vspace{2ex}

例えば:
\begin{enumerate}
\item 署名を付与して、ECDH-ephemeralの公開鍵を交換。
\item ECDH-ephemeral + AESでHMAC/AES暗号化の鍵を共有。
\item 以降の大規模データのやり取りはAES復号と同時にHMACで本人確認を実施。
\end{enumerate}

\end{frame}
\begin{frame}
図にすると:
\begin{center}
\includegraphics[width=\linewidth]{Figs/key-exchange-flow01.pdf}
\end{center}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{まとめ}
\begin{frame}
 \centering
 {\Large まとめ}
\end{frame}

\begin{frame}
\frametitle{まとめ}
お疲れ様でした。

\begin{itemize}
\item データの真正性・本人確認のためのテクニックついて学んだ。
\begin{itemize}
 \item Hash: データの「指紋」。SHA-2以降のものを使おう。
 \item MAC:
\begin{itemize}
 \item 共通鍵ベースの本人確認手法。動作が軽い。
 \item JSだととりあえずHMACを使う。
\end{itemize}
 \item 署名:
\begin{itemize}
\item 公開鍵ベースの本人確認手法。MACと比べると動作が重い。
\item RSASSA: 使うなら\alert{RSASSA-PSSがおすすめ}。
\item ECDSA: 大体どの環境でも使える。
\end{itemize}
\end{itemize}
\item 上記について、JavaScriptのコードを実行/中身を覗いてみた。
\item 署名はエンド間のやり取りイニシエーション、MACはその後のデータのやり取りに使うと良い。
\end{itemize}
\end{frame}



\input{./frame-itransfy.tex}
\input{./frame-zettant.tex}







% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \backupbegin

% \section{Backup}

% \begin{frame}
 
% \end{frame}

% \begin{frame}
% \frametitle{Appendix}
% This page is not counted.
% \end{frame}
% \backupend
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
